/*
filename: moserialruleset.cpp
author: Sherri Harms
last modified: 7/23/01
description: Class mos_ruleset implementation file for serial MINEPI REAR rules 
  	Values of this type are vectors of rules,	where a mos_rule is a composite of 
	an antecedent episode, and a consequent episode, with a confidence;
******************************************************************************
Local Data Structures:
Local variables:
*****************************************************************************
mos_ruleset operations include:
input, output, constructors, 
relational operators, accessor functions
and operations to adds rules, etc
*******************************************************************************/

#pragma warning(disable:4786)

#include "moserialruleset.h"
#include <vector>
#include <algorithm>
#include <iomanip>
#include <iostream>
using namespace std;

void mos_ruleset::cleanup()
{
	try
	{
		mosrule_set::iterator r = rs.begin();
		while (r != rs.end())
		{
//			r->output(cout);
			r->clear();
//			delete r;
//			r=0;
			r++;
		}
		clear();
	} //end try
	catch(...)
	{
//		cout<<"exception occurred"<<endl;
	}
}

void mos_ruleset::clear()
{
	rs.erase(rs.begin(), rs.end());
	count = 0;
}

int mos_ruleset::AccessCount() const
{
	return count;
}

void mos_ruleset::insertrule(const mos_rule& in_rule)
{
	rs.push_back(in_rule);
	count++;
}

mos_rule mos_ruleset::get_first_rule() const
{
	mos_rule i = *rs.begin();
	return i;
}

bool mos_ruleset::empty() const
{
	return rs.empty();
}

bool mos_ruleset::contain(const mos_rule& in_rule) const
{
	bool found = false;
	mosrule_set::const_iterator r = rs.begin();
	while (r != rs.end() && !found)
	{
		if (in_rule == *r)
			found = true;
		r++;
	}
	return found;
}

void mos_ruleset::output(ostream& outs,bool rar) const
{
	outs<<endl;
	outs<<"| ";
		if (rar)
			outs<<setw(14)<<"Representative";
		else
			outs<<setw(14)<<"All";

	outs<<setw(12)<<" Serial Rules";
		//modified 3/21/02 last occurrence
	outs<<" | "<<"Last Occurred"
		<<" | "<<"Confidence"
		<<" | "<<"Support"
		<<" | "<<"Coverage"
		<<" | "<<"Cons Freq"
		<<" | "<<"J-Measure"
		<<" |"<<endl;
	outs<<"---------------------------------------------------------------------------------------------------------"<<endl;

	mosrule_set::const_iterator i= rs.begin();
	while (i != rs.end())
	{
		(*i).output(outs);
		++i;
	}
	outs<<"---------------------------------------------------------------------------------------------------------"<<endl;
}

string mos_ruleset::outputXML(char type) const
//Purpose: To add all of the rules generated by the algorithm to an
//		XML string for output
//Author: Matt Culver
//Last Modified: 7 July 2003
//type - The type of episode that the algorthm was looking for
{
	string ruleListXML;
	
	ruleListXML = "<RuleList>";
	mosrule_set::const_iterator i= rs.begin();
	while (i != rs.end())
	{
		ruleListXML += (*i).outputXML(type);
		++i;
	}
	ruleListXML += "</RuleList>";

	return ruleListXML;
}

// Dan Li, Oct 29
void mos_ruleset::output(ostream& outs,char type, bool rar) const
{
	outs<<endl;
	outs<<"| ";
		if (rar)
			outs<<setw(14)<<"Representative";
		else
			outs<<setw(14)<<"All";

	outs<<setw(12)<<" Serial Rules";
		//modified 3/21/02 last occurrence
	outs<<setw(35)<<" | Last Occurred"
		<<" | "<<"Confidence"
		<<" | "<<"Support"
		<<" | "<<"Coverage"
		<<" | "<<"Cons Freq"
		<<" | "<<"J-Measure"
		<<" |"<<endl;
	outs<<"--------------------------------------------------------------------------------------------------------------------------"<<endl;

	mosrule_set::const_iterator i= rs.begin();
	while (i != rs.end())
	{
		(*i).output(outs, type);
		++i;
	}
	outs<<"---------------------------------------------------------------------------------------------------------------------------"<<endl;
}


mos_ruleset::mos_ruleset( )
{
	mos_rule empty;
	rs.push_back(empty);
	rs.clear();
	count = 0;
}
    //Constructor.

/*istream& operator >>(istream& ins, mos_ruleset& the_object)
    //Overloads the >> operator for input values of type mos_ruleset.
    //Precondition: If ins is a file input stream, then ins has 
    //already been connected to a file. 
{
	mos_rule i;
	ins>>i; //NOT IMPLEMENTED
	while (!ins.eof())
	{
		the_object.rs.push_back(i);
		ins>>i;
	}
	return ins;
}
*/

/*ostream& operator << (ostream& outs, const mos_ruleset& the_object)
    //Overloads the << operator for output values of type mos_ruleset.
    //Precondition: If outs is a file output stream, then outs as 
    //already been connected to a file.
{
	ostream_iterator<mos_rule> output(outs, " ");
	copy(the_object.rs.begin(), the_object.rs.end(), output);
	return outs;
}*/

