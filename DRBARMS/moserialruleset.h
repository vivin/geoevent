/*
filename: mos_ruleset.h
author: Sherri Harms
last modified: 7/23/01
description: Class mos_ruleset interface file for serial MINEPI REAR rules 
  	Values of this type are vectors of s_rules,	where a mos_rule is a composite of 
	an antecedent episode, and a consequent episode, with a confidence;
******************************************************************************
Local Data Structures:
Local variables:
*****************************************************************************
mos_ruleset operations include:
input, output, constructors, 
relational operators, accessor functions
and operations to adds rules, etc
*******************************************************************************/

#ifndef mos_RULESET_H
#define mos_RULESET_H

#include "timestamp.h"
#include "moserialrule.h"
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

typedef vector<mos_rule> mosrule_set;

class mos_ruleset
{
public:

       void cleanup();
	void clear();
	//cleare the current mos_ruleset

	void insertrule(const mos_rule& in_rule);
	//add a mos_rule into the mos_ruleset

	mos_rule get_first_rule() const;
	//return the first mos_rule

	bool empty() const;
	//true if rear empty

	bool contain(const mos_rule& in_rule) const;
	//returns true if the mos_ruleset already contains this mos_rule

	string outputXML(char type) const;
	//Purpose: To add all of the rules generated by the algorithm to an
	//		XML string for output
	//Author: Matt Culver
	//Last Modified: 7 July 2003
	//type - The type of episode that the algorthm was looking for

	void output(ostream& outs, bool rar=false) const;

	// Dan Li, Oct 29
	void output(ostream& outs, char type, bool rar=false) const;

  //  friend bool operator ==(const mos_ruleset& r1, const mos_ruleset& r2);
    //Returns true if i1 and i2 represent the same mos_ruleset; 
    //otherwise, returns false.

   // friend bool operator !=(const mos_ruleset& r1, const mos_ruleset& r2);
    //Returns true if i1 != i2 ; otherwise, returns false.

    mos_ruleset( );
    //Constructor.

	int AccessCount() const;

friend	bool operator ==(const mos_ruleset& r1, const mos_ruleset& r2)
    //Returns true if i1 and i2 represent the same mos_ruleset; 
    //otherwise, returns false.
{
	return (r1.rs==r2.rs);
}

friend bool operator !=(const mos_ruleset& r1, const mos_ruleset& r2)
    //Returns true if i1 != i2 ; otherwise, returns false.
{	
	return !(r1.rs==r2.rs);
}


 //   friend istream& operator >>(istream& ins, mos_ruleset& the_object);
    //Overloads the >> operator for input values of type mos_ruleset.
    //Precondition: If ins is a file input stream, then ins has 
    //already been connected to a file. 

  //  friend ostream& operator << (ostream& outs, const mos_ruleset& the_object);
    //Overloads the << operator for output values of type mos_ruleset.
    //Precondition: If outs is a file output stream, then outs as 
    //already been connected to a file.
private:

	mosrule_set rs;
	int count;
};

#endif //ruleset_H



