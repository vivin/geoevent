/*
filename: moruleset.h
author: Sherri Harms
last modified: 8/8/01
description: Class moruleset interface file for parallel MINEPI REAR rules 
  	Values of this type are vectors of rules,	where a morule is a composite of 
	an antecedent episode, and a consequent episode, with a confidence;
******************************************************************************
Known bugs:
  The constraints are all disjuctive singular events.
  step 5 from alg 5 generate candidatges has not been implemented
  input validation is not done
*******************************************************************************
 
Local Data Structures:
Local variables:
*****************************************************************************
moruleset operations include:
input, output, constructors, 
relational operators, accessor functions
and operations to adds rules, etc
*******************************************************************************/

#ifndef moRULESET_H
#define moRULESET_H

#include "event.h"
#include "morule.h"
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

typedef vector<event> event_set;
typedef vector<morule> p_rule_set;

class moruleset
{
public:

       void cleanup();
	void clear();
	//cleare the current moruleset

	void insertrule(const morule& in_rule);
	//add a morule into the moruleset

	morule get_first_rule() const;
	//return the first morule

	bool empty() const;
	//true if rear empty

	bool contain(const morule& in_rule) const;
	//returns true if the moruleset already contains this morule

	string outputXML(char type) const;
	//Purpose: To add all of the rules generated by the algorithm to an
	//		XML string for output
	//Author: Matt Culver
	//Last Modified: 6 July 2003
	//type - The type of episode that the algorthm was looking for

	void output(ostream& outs, bool rar=false) const;
	// Dan Li, oct29, add one more parameter to output
	void output(ostream& outs, char type, bool rar=false) const;

   friend bool operator ==(const moruleset& r1, const moruleset& r2)
    //Returns true if i1 and i2 represent the same moruleset; 
    //otherwise, returns false.
{
	return (r1.rs==r2.rs);
}

friend bool operator !=(const moruleset& r1, const moruleset& r2)
    //Returns true if i1 != i2 ; otherwise, returns false.
{	
	return !(r1.rs==r2.rs);
}

	
	moruleset( );
    //Constructor.

	int AccessCount() const;

 /*   friend istream& operator >>(istream& ins, moruleset& the_object)
    //Overloads the >> operator for input values of type moruleset.
    //Precondition: If ins is a file input stream, then ins has 
    //already been connected to a file. 
    //Overloads the >> operator for input values of type moruleset.
    //Precondition: If ins is a file input stream, then ins has 
    //already been connected to a file. 
{
	morule i;
	ins>>i; //NOT IMPLEMENTED
	while (!ins.eof())
	{
		the_object.rs.push_back(i);
		ins>>i;
	}
	return ins;
}


    friend ostream& operator << (ostream& outs, const moruleset& the_object)
    //Overloads the << operator for output values of type moruleset.
    //Precondition: If outs is a file output stream, then outs as 
    //already been connected to a file.

    //Overloads the << operator for output values of type moruleset.
    //Precondition: If outs is a file output stream, then outs as 
    //already been connected to a file.
{
	ostream_iterator<morule> output(outs, " ");
	copy(the_object.rs.begin(), the_object.rs.end(), output);
	return outs;
}
*/
private:

	p_rule_set rs;
	int count;
};

#endif //ruleset_H



